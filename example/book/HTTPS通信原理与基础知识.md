---
title: HTTPS通信原理与基础知识
date: 2020-11-13
categories:
 - 书籍
tags:
 - HTTPS
---

## 什么是HTTPS

> HTTPS是建立在SSL/TLS上的通信

- HTTP：在应用层上运行，它是直接与TCP进行通信

- HTTPS：在通信层上运行，它与SSL通信， SSL再与TCP进行通信。

其实，HTTPS就是披上SSL协议外壳的HTTP

![https/image-20200728162101829](/https/image-20200728162101829.png)

### 

HTTPS通信，就是先建立一个SSL/TLS通信，然后再内部进行HTTP通信

### 为什么有HTTPS

在这里，我们需要理解为什么要有HTTPS

- 报文明文发送

在传统的HTTP通信中，我们的传输信息是明文的，这样在一些铭感数据上会被黑客劫持修改，造成数据安全问题，所以对HTTP的加密就尤为重要，那解决方法就是采用SSL/TLS先进行建立连接，之后再进行通信，这样就可以实现对数据进行加密。

- 无法验证报文完整性

因为HTTP是通过明文传输报文的，就无法验证我的报文在客户端到服务端的过程中是否有被劫持修改。

- 不验证对方身份，可能遭遇伪装攻击

HTTP协议中响应和请求是不会对通信方进行确认的，这样任何人都可以发起请求，不管谁都会被响应，这样会导致"钓鱼欺诈"，用户无法察觉。例如：

> 假设你在古代，你出门在外，妻子在家养子。你们家有个箱子，箱子上有把锁，这就是你和你妻子互通的工具。你媳妇儿负责往箱子里放东西，然后上锁。你有把独特的钥匙，你负责开锁，取东西。可是你再将箱子给镖局托运的的过程中，被镖局的“小黑”掉包了，箱子的外表一致，锁看起来也一样，可是已经不是你的箱子了。因为路途遥远，古代又没有什么iPhone啥的，你媳妇没办法来辨别该箱子是否是原装的。然后就将一些东西放在了箱子里边，然后上锁交给了镖局的“小黑”。
>
> 因为“小黑”掉包的箱子，所以小黑有箱子的钥匙呢，然后就可以打开这个箱子，取东西了。原来的箱子又在小黑那，小黑就可以往原来的箱子里边随便往箱子放点没有价值的东西给你就行了。当你发现箱子里的东西不是你想要的时候，完了，小黑从镖局辞职了，找不到人了。找镖局的人讨说法，可是镖局的人说“小黑”是镖局的临时工，这个责任镖局说了，我们不能担。鉴于你无权无势，这事儿也就此罢了。(故事纯属虚构，如有雷同纯属巧合)

### HTTPS如何解决HTTP的问题

- **加密**

HTTPS采用了：非对称加密 + 对称加密的方式进行加密

非对称加密：用于秘钥交换

对称加密：用于数据加密

具体内容参见HTTPS如何通信章节

- **报文完整性验证**

HTTPS采用了数字签名的方式（即：摘要算法）对数据完整性进行了校验，过程如下：

用散列算法（SHA、MD5）对报文加密，获得摘要值，客户端再用服务端公钥对摘要和报文内容进行加密，然后传送给服务端。服务端拿到之后用私钥解密获得原始的报文内容和摘要值，这时服务端使用相同的散列算法对报文内容进行加密，再与摘要进行比对，如果一直则代表信息完整。

![https/image-20200728173323853](/https/image-20200728173323853.png)

- **身份验证**

HTTPS采用第三方可信机构CA来做身份认证，CA证书在HTTPS中使用如下：

1. 服务器运营人员向第三方CA机构提交公钥，组织信息，个人信息等申请认证，CA会验证组织或个人的合法性，然后CA会将证书内容（服务器公钥 + 证书持有人信息 + 签名信息....）进行散列算法获得证书摘要，之后通过CA证书的私钥加密生成摘要密文，然后将 证书内容 + 证书摘要密文 + 散列算法 =生成=> 数字证书![https/image-20200728175619676](/https/image-20200728175619676.png)

2. 服务器将该证书发送给客户端
3. 客户端内置CA机构的公钥，公钥对加密密文进行解密，然后通过散列算法对证书内容进行加密之后对比，这样可以得到证书是否有问题，如果有问题则会提示证书非法

![https/image-20200728175800199](/https/image-20200728175800199.png)

## 什么是SSL和TLS

> SSL是TLS的前身，他们是一个东西，但是SSL因为安全性被弃用了

| 协议    | 年份 | 状态 |
| ------- | ---- | ---- |
| SSL 2.0 | 1995 | 弃用 |
| SSL 3.0 | 1996 | 弃用 |
| TLS 1.0 | 1999 |      |
| TLS 1.1 | 2006 |      |
| TLS 1.2 | 2008 |      |
| TLS 1.3 | 2018 |      |

### SSL和TLS的差异

- 版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。
- 报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用了RFC-2104定义的HMAC算法。SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。
- 伪随机函数：TLS使用了称为PRF的伪随机函数来将密钥扩展成数据块，是更安全的方式。
- 报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。
- 密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。
- certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。
- 加密计算：TLS与SSLv3.0在计算主密值（master secret）时采用的方式不同。
- 填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。

参考：https://www.linuxidc.com/Linux/2016-05/131147.htm

## TLS1.2 HTTPS如何通信

![https/image-20200728191428361](/https/image-20200728191428361.png)

1. **客户端 Client Hello：**  报文开始 SSL 通信。报文中包含：
   - 客户端支持的 **SSL 指定版本**
   - **加密套件（Cipher Suite）**列表、
   - 客户端随机数（**Client random**）
2. **服务器 Server Hello：**  报文作为应答。和客户端一样，在报文中包含：
   -  S**SL 版本** ，如果和客户端不一致则关闭通道
   - 选定的**加密套件** ：是从接收到的客户端加密组件内筛选出来的
   - 服务端随机数（**Server random** ）
3. **服务器Server Certificate**： 报文。报文中包含公开密钥证书。
4. **服务器Server Hello Done：** 报文通知客户端，最初阶 段的 SSL 握手协商部分结束。 
5. SSL 第一次握手结束之后，客户端 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串（客户端自己通过RSA或DH计算的，之后通过证书的公钥加密传送）。该报文已用步骤 3 中的公开密钥进行加密。 
6. 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 
7. 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。
8. 服务器同样发送 Change Cipher Spec 报文。 
9. 服务器同样发送 Finished 报文。 
10. 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接 就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求（此时客户端与服务端一共拥有三个随机数：Client random + Server random + Pre-master secret，他们将会生成会话密钥（session key），将用来加密接下来的整个对话过程）。 
11. 应用层协议通信，即发送 HTTP 响应。
12. 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。

在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。







### Step 1：Client Hello（Client -> Server）

![https/image-20200729185614953](/https/image-20200729185614953.png)

第一步，客户端发送Client Hello给服务器，这其中包含了以下信息：

- Client Version：客户端发送自己所支持的TLS/SSL协议版本列表，其中首选的是列表中的第一个
- Client Random：32位的随机数，Client Random和Server Random将用于生成加密密钥，在最初的tls1.2规范中，前四个字节应该表示客户机的当前日期和时间（epoch格式），剩下的28个字节应该是随机生成的数字，但是后来IETF建议反对它
- Session ID：这是用于连接会话的ID，如果Session ID不为空，服务器将搜索以前缓存的会话，如果找到匹配项，则恢复该会话
- compression_methods：这是用于压缩SSL包的方法，通过压缩，可以减少带宽使用率，但是压缩是有风险的。
- Cipher Suites：密码套件是密码算法的组合。通常，每个密码套件包含一个用于以下任务的加密算法：密钥交换，身份验证，批量（数据）加密和消息身份验证。客户端按自己的优先级顺序发送，也就是第一个密码套件是客户端最优的。具体密码套件的解析参见下方密码套件内容。
- Compression Methods：这个是数据压缩的算法。
- Extensions：这个是附加参数，因为SSL协议起草之初有些功能没有考虑到，后续这些功能被加进RFC，而为了兼容SSL，把这些功能的描述放到Extension中。

### Step 2： Server Hello (Server → Client)

![https/image-20200729185605955](/https/image-20200729185605955.png)

在收到Client Hello后，服务端将会发出Server Hello

- Server Version：服务端选择的SSL/TLS协议版本
- Server Random：32位随机数，Client Random和Server Random将用于生成加密密钥，在最初的tls1.2规范中，前四个字节应该表示客户机的当前日期和时间（epoch格式），剩下的28个字节应该是随机生成的数字，但是后来IETF建议反对它
- Session ID：这是用于连接会话的ID，如果Session ID不为空，服务器将搜索以前缓存的会话，如果找到匹配项，则恢复该会话。

- compression_methods：这是用于压缩SSL包的方法，通过压缩，可以减少带宽使用率，但是压缩是有风险的。
- Cipher Suites：服务端在Client Hello 发送的密码套件中所选择的。

### Step 3: Server Certificate (Server → Client)

服务端此时想客户端发送一个SSL/TLS证书，证书内包含了服务器的公钥

### Step 4: Client Certificate (Client → Server, Optional)

有时候连接需要客户端认证，此时客户端会将自己的证书发送给服务器

### Step 5: Server Key Exchange (Server → Client)

只有当服务器提供的证书不足以让客户端交换主控密钥时，才会发送服务器密钥交换消息。（对于DHE_DSS、DHE_RSA和DH_anon来说也是如此）。

### Step 6: Server Hello Done (Server → Client)

服务器将此消息发送到客户端，以确认服务器Hello消息已完成。

### Step 7: Client Key Exchange (Server → Client)

![https/image-20200729185554965](/https/image-20200729185554965.png)

客户机密钥交换消息是在从服务器接收到服务器Hello Done之后发送的。如果服务器请求客户端证书，则在该证书之后发送客户端密钥交换。在此阶段，客户端将创建一个预主密钥。

#### Pre-Master Secret

> PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。

Pre-Master Secret 的创建是由客户端与服务端通信所协商的加密套件算法计算（Diff-Hellman/RSA），之后将会与服务端进行公钥加密后共享

#### Master Secret

当服务端收到Pre-Master Secret 之后，将会用私钥解密，现在客户端和服务端都有Client Random和Server Random以及Pre-Master Secret ，客户端和服务端此时会用伪随机函数（PRF）计算Master Secret

```
master_secret = PRF(pre_master_secret, "master secret", ClientHello.random + ServerHello.random) [0..47];
```

然后，客户机和服务器将使用长度为48字节的主密钥对通信的其余部分的数据进行对称加密。

- **client_write_MAC_key：** 身份验证和完整性检查
- **server_write_MAC_key：** 身份验证和完整性检查
- **client_write_key： **使用对称密钥的消息加密
- **server_write_key：** 使用对称密钥的消息加密
- **client_write_IV： **一些提前加密使用的初始化向量
- **server_write_IV：** 一些前置密码使用的初始化向量

客户端和服务器都将使用Master Secret 来生成会话密钥，这些密钥将用于加密/解密数据，也就是上面的6个，他们将有master_secret进行分割获取，如果Master Secret 长度不够，将会进行扩展计算到需要的长度。

```
key_block = PRF(SecurityParameters.master_secret,"key expansion",SecurityParameters.server_random +SecurityParameters.client_random);
```



这里为什么要三个随机数来生成“会话秘钥”，是因为：

> "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
>
> 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
>
> pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"







### Step 9: Client Handshake Finished (Client → Server)

来自客户机的握手过程的最后一条消息表示握手已经完成。这也是安全连接的第一个加密消息。

![https/image-20200730102504901](/https/image-20200730102504901.png)

### Step 10: Server Change Cipher Spec (Server → Client)

服务器也可以切换到加密的环境。从现在开始，服务器发送的任何数据都将使用对称共享密钥进行加密。

### Step 11: Server Handshake Finished (Server → Client)

来自服务器的握手过程的最后一条消息(发送加密)表示握手已经完成。

![https/image-20200730102655288](/https/image-20200730102655288.png)



## TLS1.3 HTTPS如何通信

在TLS1.2和更早的版本中，TLS握手需要两次往返，第一次往返交换hellos，第二次交换key以及改变加密算法。在TLS1.3中，只需要一次往返，TLS1.3不支持TLS压缩

![https/image-20200730104237046](/https/image-20200730104237046.png)

在TLS1.3中，当客户端发出hello时，它立即猜测服务器最有可能选择的秘钥协议。同时他使用猜到的协议共享他的秘钥。服务器的hello消息还包含秘钥，证书和服务器完成消息。不需要改变密码，因为在交换了hellos之后，双方已经拥有了加密通信所需的所以信息。

## HTTPS算法

### 密码套件

在HTTPS交换过程中，一个密码套件包括了什么内容呢？

> **密钥交换算法：** 用于决定客户端与服务器之间在握手的过程中如何认证，用到的包括RSA、Diffie-Hellman、ECDH、PSK等
>
> **加密算法：** 用于加密消息流，该名称后通常会带有两个数字，分别表示密钥的长度和初始向量的长度，比如DES 56/56, RC2 56/128, RC4 128/128, AES 128/128, AES 256/256
>
> **报文认证信息码（MAC）算法：** 用于创建报文摘要，确保消息的完整性，算法包括MD5、SHA
>
> **PRF（伪随机数函数）： **用于生成“master secret”



浏览器与服务器密码套件配置：https://www.cnblogs.com/TIlifeng/p/5488301.html

密码套件Hex表：https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4

密码套件：**TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA**，它的意思是：

- 基于TLS协议
- 使用ECDHE、RSA作为**密钥交换算法**
- AES作为**加密算法** ，秘钥和初始向量长度都是256
- **MAC算法** 采用SHA

### 摘要算法

#### 概念

摘要算法的主要特征是加密国产不需要密钥，并且经过加密的数据无法被破解，目前可以被解密逆向的只有CRC32算法，只有输入相同的铭文数据经过相同的摘要算法才能得到相同的密文。

摘要算法的主要应用是在“数字签名”领域，著名的摘要算法有MAC及RSA公司的MD5算法和SHA-1算法及其大量的变体

#### 特点

消息摘要是把任意长度的输入柔和而产生固定的伪随机输入的算法。主要特点有：

- 无论输入消息多长，算出来的消息摘要长度是固定的。例如MD5算法摘要的消息有128Bit，SHA-1有160Bit，SHA-1的变体可以产生192Bit和235Bit的消息摘要，一般认为，最终的输出越长越安全。
- 伪随机的，一般真正的随机相同的输入是无法产生相同输出的。
- 相同的输入会产生相同的输出，不同的输入会产生不同的输出。
- 摘要算法是单向的，不可逆，只能采用强力攻击的方法尝试每一个可能的消息，计算其摘要，看看与现有摘要是否相同。但是这个需要枚举无穷个可能，这种攻击几乎是无效的。
- 好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。即对于给定的一个摘要，不可能找到一条信息使其摘要正好是给定的。或者说，无法找到两条消息，使它们的摘要相同。

#### 分类

**MD5：**

MD算法：生成的消息摘要都是128位的，安全性MD5 > MD4 > MD2

| 算法 | 摘要长度 | 实现方        |
| ---- | -------- | ------------- |
| MD2  | 128      | JDK           |
| MD4  | 128      | Bouncy Castle |
| MD5  | 128      | JDK           |

实现代码参考：https://blog.csdn.net/weixin_38638777/article/details/79608356

**SHA：**

安全散列算法，固定长度摘要信息，包括SHA-1、SHA-2（SHA-224，SHA-256，SHA-384，SHA-512）

| 算法    | 摘要长度 | 实现方        |
| ------- | -------- | ------------- |
| SHA-1   | 160      | JDK           |
| SHA-224 | 224      | Bouncy Castle |
| SHA-256 | 256      | JDK           |
| SHA-384 | 384      | JDK           |
| SHA-512 | 512      | JDK           |

实现代码参考：https://blog.csdn.net/weixin_38638777/article/details/79608356

**MAC：**

HMAC(keyed-Hash Message Authentication Code)：含有密钥的散列函数算法，他包含了MD5与SHA两个系列的摘要算法，HMAC只是在原有的MD和SHA算法基础上添加了密钥。

MD系列：HmacMD2，HmacMD4，HmacMD5

SHA系列：HmacSHA1，HmacSHA224，HmacSHA256，HmacSHA38，HmacSHA512

| 算法       | 摘要长度 | 实现方        |
| ---------- | -------- | ------------- |
| HmacMD2    | 128      | Bouncy Castle |
| HmacMD4    | 128      | Bouncy Castle |
| HmacMD5    | 128      | JDK           |
| HmacSHA1   | 160      | JDK           |
| HmacSHA224 | 224      | Bouncy Castle |
| HmacSHA256 | 256      | JDK           |
| HmacSHA384 | 384      | JDK           |
| HmacSHA512 | 512      | JDK           |

实现代码参考：https://blog.csdn.net/weixin_38638777/article/details/79608356

### 对称算法

#### 概念

对称加密算法指的是加密与解密采用相同的密钥。

#### 特点

对称算法的特点是算法公开，计算量小，加密速度块，加密效率高

#### 分类

常见的对称算法有：DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish等。

**DES：**

DES是最基本的对称加密算法，DES来自IBM之手，DES采用56位密钥，以现代计算能力，24小时内即可破解。DES算法的入口参数有三个，Key、Data、Mode。其中Key为8个字节共64位，是DES算法的工作密钥；Data也为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式,有两种：加密或解密。

**AES：**

AES是美国联邦政府采用的一种区块加密标准，这个标准用于代替原先的DES。

**SM1：**

SM1是国家密码管理局编制的一种商用密码分组标准对称算法，目前该算法不公开，其强度与AES相当。

**SM4：**

SM4是国家密码管理局发布的对称算法，其分组长度为128bit，密钥长度为128bit。加密算法与密钥扩展算法均采用32轮非线性迭代结构。

### 非对称算法

#### 概念

非对称加密较之前的对称加密而言，更为复杂，涉及到了例如欧拉公式、费马小定理、中国剩余定理等众多的数学基础，但是简单的来讲，所谓非对称加密，就是加密和解密使用的不是同一个密钥，比如现在有一对密钥（Pubkey，Prikey），

Pubkey称之为公钥，Prikey称之为私钥，所谓“非对称”性：

**(1)：使用Pubkey加密的数据，只能用Prikey解密。**

**(2)：使用Prikey加密的数据，只能使用Pubkey解密。**

只要Pubkey和Prikey之间满足一定的数学关系就能达到这种对称性，而这种数学关系，即不能从Pubkey推导出Prikey，也不能从Prikey推导出Pubkey。

#### 特点

非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要`N*(N-1)/2`个密钥，因此每个人需要管理`N-1`个密钥，密钥管理难度大，而且非常容易泄漏。

#### 分类

主要的非对称算法有：RSA、DH、ECC

**RSA**

RSA 是一种目前应用非常广泛、在1977年被麻省理工学院的三位科学家提出，由于难于破解，RSA 是目前应用最广泛的数字加密和签名技术，比如国内的支付宝就是通过RSA算法来进行签名验证。它的安全程度取决于秘钥的长度，目前主流可选秘钥长度为 1024位、2048位、4096位等，理论上秘钥越长越难于破解，按照维基百科上的说法，小于等于256位的秘钥，在一台个人电脑上花几个小时就能被破解，512位的秘钥和768位的秘钥也分别在1999年和2009年被成功破解，虽然目前还没有公开资料证实有人能够成功破解1024位的秘钥，但显然距离这个节点也并不遥远，所以目前业界推荐使用 2048 位或以上的秘钥，不过目前看 2048 位的秘钥已经足够安全了，支付宝的官方文档上推荐也是2048位，当然更长的秘钥更安全，但也意味着会产生更大的性能开销。

**DH**

DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。

我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：

1. 甲首选选择一个素数`p`，例如509，底数`g`，任选，例如5，随机数`a`，例如123，然后计算`A=g^a mod p`，结果是215，然后，甲发送`p＝509`，`g=5`，`A=215`给乙；
2. 乙方收到后，也选择一个随机数`b`，例如，456，然后计算`B=g^b mod p`，结果是181，乙再同时计算`s=A^b mod p`，结果是121；
3. 乙把计算的`B=181`发给甲，甲计算`s＝B^a mod p`的余数，计算结果与乙算出的结果一样，都是121。

所以最终双方协商出的密钥`s`是121。注意到这个密钥`s`并没有在网络上传输。而通过网络传输的`p`，`g`，`A`和`B`是无法推算出`s`的，因为实际算法选择的素数是非常大的。

所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。

如果我们把`a`看成甲的私钥，`A`看成甲的公钥，`b`看成乙的私钥，`B`看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥`secretKey`，DH算法通过数学定律保证了双方各自计算出的`secretKey`是相同的。

代码实现参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227905273889

**ECC**

> 椭圆加密算法（ECC）是一种公钥加密算法，最初由 Koblitz 和 Miller 两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成 Abel 加法群上椭圆离散对数的计算困难性。公钥密码体制根据其所依据的难题一般分为三类：大整数分解问题类、离散对数问题类、椭圆曲线类。有时也把椭圆曲线类归为离散对数类。

ECC 的主要优势是在某些情况下它比其他的方法使用更小的密钥 (比如 RSA)，提供相当的或更高等级的安全。ECC 的另一个优势是可以定义群之间的双线性映射，基于 Weil 对或是 Tate 对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。

ECC 被广泛认为是在给定密钥长度的情况下，最强大的非对称算法，因此在对带宽要求十分紧的连接中会十分有用。

> 比特币钱包公钥的生成使用了椭圆曲线算法，通过椭圆曲线乘法可以从私钥计算得到公钥， 这是不可逆转的过程。

## 参考文章

[深入理解HTTPS工作原理](/https://segmentfault.com/a/1190000018992153)

 [图解SSL/TLS协议-阮一峰](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

[一文看懂HTTPS、证书机构（CA）、证书、数字签名、私钥、公钥](/https://www.jianshu.com/p/29e0ba31fb8d)

[SSL协议握手过程报文解析](/https://blog.csdn.net/tterminator/article/details/50675540)

[数字签名与HTTPS详解](/https://www.cnblogs.com/rinack/p/10743355.html)

[HTTPS加密（握手）过程](/https://www.jianshu.com/p/e30a8c4fa329)

[TLSv1.2抓包解密分析过程之RSA_WITH_AES_128_CBC_SHA256](/https://blog.csdn.net/wzj_whut/article/details/86626529)